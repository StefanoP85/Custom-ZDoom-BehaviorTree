//==============================================================================
//
// Cyber monster base class.
//
//==============================================================================

// -----------------------------------------------------------------------------
// Event handler.
// -----------------------------------------------------------------------------

class TCyberEventHandler : EventHandler
{
	Array< Class<Actor> > CriticalClasses;
	Array< Class<Actor> > DangerousClasses;
	Array<Actor> MonsterList;
	TNavMeshActors NavMeshActors;
	override void OnRegister()
	{
		NavMeshActors = TNavMeshActors.GetInstance();
	}
	override void WorldThingSpawned(WorldEvent E)
	{
		if ( E.Thing && E.Thing.bIsMonster )
		{
			MonsterList.Push(E.Thing);
			let CustomNavMeshActor = TCustomNavMeshActor(E.Thing);
			if (CustomNavMeshActor)
				NavMeshActors.GetInstance().AddMonster(CustomNavMeshActor);
		}
	}
	override void WorldThingDestroyed(WorldEvent E)
	{
		if ( E.Thing )
		{
			int Index = MonsterList.Find(E.Thing);
			if (Index != MonsterList.Size())
				MonsterList.Delete(Index);
		}
	}
	void AddCriticalClass(Class<Actor> ClassName)
	{
		if (CriticalClasses.Find(ClassName) == CriticalClasses.Size())
			CriticalClasses.Push(ClassName);
	}
	void AddDangerousClass(Class<Actor> ClassName)
	{
		if (DangerousClasses.Find(ClassName) == DangerousClasses.Size())
			DangerousClasses.Push(ClassName);
	}
	bool IsCritical(Class<Actor> ClassName)
	{
		return CriticalClasses.Find(ClassName) < CriticalClasses.Size();
	}
	bool IsDangerous(Class<Actor> ClassName)
	{
		return DangerousClasses.Find(ClassName) < DangerousClasses.Size();
	}
}

// -----------------------------------------------------------------------------
// Priority queue.
// -----------------------------------------------------------------------------

enum TThreatLevel
{
	THREAT_ASSESS = 0,
	THREAT_NONE = 1,
	THREAT_VERYLOW = 2,
	THREAT_LOW = 3,
	THREAT_MILD = 4,
	THREAT_NORMAL = 5,
	THREAT_ABOVENORMAL = 6,
	THREAT_DANGEROUS = 7,
	THREAT_VERYDANGEROUS = 8,
	THREAT_SUPERDANGER = 9,
	THREAT_UNSTOPPABLE = 666,
}

enum TExperiencedThreatLevel
{
	ETL_INITIAL = 0,
	ETL_NORMAL = 1,
	ETL_DANGER = 2,
	ETL_CRITICAL = 3
}

class TPriorityQueueItem : Thinker
{
	Actor Monster;
	TThreatLevel ThreatLevel;
	TExperiencedThreatLevel ExperiencedThreatLevel;
	int TotalDamage;
	int Timer;
	static TPriorityQueueItem Create(Actor Monster, TThreatLevel ThreatLevel, TExperiencedThreatLevel ExperiencedThreatLevel)
	{
		TPriorityQueueItem PriorityQueueItem = New('TPriorityQueueItem');
		PriorityQueueItem.ChangeStatNum(STAT_INFO);
		PriorityQueueItem.Monster = Monster;
		PriorityQueueItem.ThreatLevel = ThreatLevel;
		PriorityQueueItem.ExperiencedThreatLevel = ExperiencedThreatLevel;
		PriorityQueueItem.TotalDamage = 0;
		PriorityQueueItem.Timer = 4200; // 4200 TICS, 120 seconds.
		return PriorityQueueItem;
	}
}

class TPriorityQueue : Thinker
{
	Array<TPriorityQueueItem> Items;
	int ItemsCount;
	static TPriorityQueue Create()
	{
		TPriorityQueue PriorityQueue = New('TPriorityQueue');
		PriorityQueue.ChangeStatNum(STAT_INFO);
		return PriorityQueue;
	}
	int Compare(int A, int B)
	{
		if (Items[A].ExperiencedThreatLevel > Items[B].ExperiencedThreatLevel)
			return 1;
		else
			if (Items[A].ExperiencedThreatLevel < Items[B].ExperiencedThreatLevel)
				return -1;
			else
				if (Items[A].ThreatLevel > Items[B].ThreatLevel)
					return 1;
				else
					if (Items[A].ThreatLevel < Items[B].ThreatLevel)
						return -1;
					else
						return 0;
	}
	int GetParent(int Index)
	{
		return (Index - 1) / 2;
	}
	int GetLeftChild(int Index)
	{
		return ((Index * 2) + 1);
	}
	int GetRightChild(int Index)
	{
		return ((Index * 2) + 2);
	}
	void Swap(int A, int B)
	{
		TPriorityQueueItem Tmp = Items[A];
		Items[A] = Items[B];
		Items[B] = Tmp;
	}
	void BubbleUp(int Index)
	{
		if (Index < Items.Size())
		{
			int IndexParent = GetParent(Index);
			while ((Index > 0) && (Compare(IndexParent, Index) < 0))
			{
				Swap(IndexParent, Index);
				Index = IndexParent;
				IndexParent = GetParent(Index);
			}
		}
	}
	void BubbleDown(int Index)
	{
		int Pivot, Left, Right;
		do
		{
			Pivot = -1;
			Right = GetRightChild(Index);
			if ((Right < ItemsCount) && (Compare(Right, Index) < 0))
			{
				Left = GetLeftChild(Index);
				if (Compare(Left, Right) < 0)
					Pivot = Left;
				else
					Pivot = Right;
			}
			else
			{
				Left = GetLeftChild(Index);
				if ((Left < ItemsCount) && (Compare(Left, Index) < 0))
					Pivot = Left;
			}
			if (Pivot >= 0)
				Swap(Index, Pivot);
			Index = Pivot;
		} while (Index >= 0);
	}
	int Find(Actor Monster)
	{
		int Index = 0;
		bool NotFound = True;
		while ((NotFound) && (Index < ItemsCount))
			if (Items[Index].Monster == Monster)
				NotFound = False;
			else
				Index++;
		if (NotFound)
			return -1;
		else
			return Index;
	}
	void Insert(Actor Monster, TThreatLevel ThreatLevel, TExperiencedThreatLevel ExperiencedThreatLevel)
	{
		TPriorityQueueItem PriorityQueueItem = TPriorityQueueItem.Create(Monster, ThreatLevel, ExperiencedThreatLevel);
		Items.Push(PriorityQueueItem);
		BubbleUp(ItemsCount);
		ItemsCount++;
	}
	void Remove(int Index)
	{
		Items.Delete(Index);
		ItemsCount--;
		BubbleDown(Index);
	}
	void UpdatePriority(Actor Monster, TThreatLevel ThreatLevel, TExperiencedThreatLevel ExperiencedThreatLevel)
    {
        int Index = Find(Monster);
		if (Index >= 0)
		{
			Items[Index].ThreatLevel = ThreatLevel;
			Items[Index].ExperiencedThreatLevel = ExperiencedThreatLevel;
			BubbleUp(Index);
		}
    }
}

// -----------------------------------------------------------------------------
// Behavior tree
// -----------------------------------------------------------------------------

// Return values of and valid states for behaviors.
enum TStatus
{
	BH_INVALID,
	BH_SUCCESS,
	BH_FAILURE,
	BH_RUNNING,
	BH_ABORTED,
}
enum TParallelPolicy
{
	BP_RequireOne,
	BP_RequireAll
}

class TBehavior: Thinker abstract
{
	TStatus Status;
	virtual TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		return BH_INVALID;
	}
	virtual void OnInitialize()
	{
	}
	virtual void OnTerminate(TStatus Status)
	{
	}
	virtual void Initialize()
	{
		Status = BH_INVALID;
	}
	TStatus Think(TCustomCyberActor CustomCyberActor)
	{
		if (Status != BH_RUNNING)
			OnInitialize();
		Status = Update(CustomCyberActor);
		if (Status != BH_RUNNING)
			OnTerminate(Status);
		return Status;
	}
	void Abort()
	{
		OnTerminate(BH_ABORTED);
		Status = BH_ABORTED;
	}
	void Reset()
	{
		Status = BH_INVALID;
	}
	bool IsRunning()
	{
		return Status == BH_RUNNING;
	}
	bool IsTerminated()
	{
		return (Status == BH_SUCCESS) || (Status == BH_FAILURE);
	}
}

class TDecorator : TBehavior abstract
{
	TBehavior Behavior;
	override TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		return Behavior.Think(CustomCyberActor);
	}
}

class TRepeat : TDecorator
{
	int Limit;
	static TRepeat Create(TBehavior Behavior)
	{
		TRepeat Result = New('TRepeat');
		Result.Initialize();
		Result.Behavior = Behavior;
		return Result;
	}
	override void Initialize()
	{
		super.Initialize();
		Limit = 0;
	}
	override TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		int Counter = 0;
		while (True)
		{
			Behavior.Think(CustomCyberActor);
			if (Behavior.Status == BH_RUNNING)
				break;
			if (Behavior.Status == BH_FAILURE)
				return BH_FAILURE;
			if (++Counter == Limit)
				return BH_SUCCESS;
			Behavior.Reset();
		}
		return BH_INVALID;
	}
}

class TRetryUntilSuccessful : TDecorator
{
	int Limit;
	static TRetryUntilSuccessful Create(TBehavior Behavior)
	{
		TRetryUntilSuccessful Result = New('TRetryUntilSuccessful');
		Result.Initialize();
		Result.Behavior = Behavior;
		return Result;
	}
	override void Initialize()
	{
		super.Initialize();
		Limit = 0;
	}
	override TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		int Counter = 0;
		while (True)
		{
			Behavior.Think(CustomCyberActor);
			if (Behavior.Status == BH_RUNNING)
				break;
			if (Behavior.Status == BH_SUCCESS)
				return BH_SUCCESS;
			if (Behavior.Status == BH_FAILURE)
				return BH_FAILURE;
			if (++Counter == Limit)
				break;
			Behavior.Reset();
		}
		return BH_FAILURE;
	}
}

class TComposite : TBehavior abstract
{
	Array<TBehavior> Behaviors;
	int CurrentIndex;
	override void Initialize()
	{
		super.Initialize();
		for (int I = 0; I < Behaviors.Size(); I++)
			Behaviors[I].Initialize();
		CurrentIndex = 0;
	}
	void AddBehavior(TBehavior Behavior)
	{
		Behaviors.Push(Behavior);
	}
	void RemoveBehavior(TBehavior Behavior)
	{
		int Index = Behaviors.Find(Behavior);
		if (Index != Behaviors.Size())
			Behaviors.Delete(Index);
	}
}

class TSequence : TComposite
{
	static TSequence Create(TBehavior Behavior)
	{
		TSequence Result = New('TSequence');
		Result.Initialize();
		Result.AddBehavior(Behavior);
		return Result;
	}
	override TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		CurrentIndex = 0;
		// Keep going until a child behavior says it's running.
		while (CurrentIndex < Behaviors.Size())
		{
			TStatus S = Behaviors[CurrentIndex].Think(CustomCyberActor);
			// If the child fails, or keeps running, do the same.
			if (S != BH_SUCCESS)
				return S;
			CurrentIndex++;
		}
		// Hit the end of the array, job done!
		return BH_SUCCESS;
	}
}

class TSelector : TComposite
{
	static TSelector Create(TBehavior Behavior)
	{
		TSelector Result = New('TSelector');
		Result.Initialize();
		Result.AddBehavior(Behavior);
		return Result;
	}
	override TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		CurrentIndex = 0;
		// Keep going until a child behavior says it's running.
		while (CurrentIndex < Behaviors.Size())
		{
			TStatus S = Behaviors[CurrentIndex].Think(CustomCyberActor);
			// If the child succeeds, or keeps running, do the same.
			if (S != BH_FAILURE)
				return S;
			CurrentIndex++;
		}
		// Hit the end of the array, it didn't end well.
		return BH_FAILURE;
	}
}

class TParallel : TComposite
{
	TParallelPolicy SuccessPolicy;
	TParallelPolicy FailurePolicy;
	static TParallel Create(TBehavior Behavior, TParallelPolicy SuccessPolicy, TParallelPolicy FailurePolicy)
	{
		TParallel Result = New('TParallel');
		Result.Initialize();
		Result.AddBehavior(Behavior);
		Result.SuccessPolicy = SuccessPolicy;
		Result.FailurePolicy = FailurePolicy;
		return Result;
	}
	override TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		int SuccessCount = 0;
		int FailureCount = 0;
		CurrentIndex = 0;
		while (CurrentIndex < Behaviors.Size())
		{
			if (!Behaviors[CurrentIndex].IsTerminated())
				Behaviors[CurrentIndex].Think(CustomCyberActor);
			if (!Behaviors[CurrentIndex].Status == BH_SUCCESS)
			{
				++SuccessCount;
				if (SuccessPolicy == BP_RequireOne)
					return BH_SUCCESS;
			}
			if (!Behaviors[CurrentIndex].Status == BH_FAILURE)
			{
				++FailureCount;
				if (FailurePolicy == BP_RequireOne)
					return BH_FAILURE;
			}
			CurrentIndex++;
		}
		if ((SuccessPolicy == BP_RequireAll) && (SuccessCount == Behaviors.Size()))
			return BH_SUCCESS;
		if ((FailurePolicy == BP_RequireAll) && (FailureCount == Behaviors.Size()))
			return BH_FAILURE;
		return BH_RUNNING;
	}
	override void OnTerminate(TStatus Status)
	{
		super.OnTerminate(Status);
		for (CurrentIndex = 0; CurrentIndex < Behaviors.Size(); CurrentIndex++)
			if (Behaviors[CurrentIndex].IsRunning())
				Behaviors[CurrentIndex].Abort();
	}
}

class TBehaviorTree: Thinker
{
	Class<TCustomCyberActor> ClassName;
	TBehavior Behavior;
	static TBehaviorTree Create(Class<TCustomCyberActor> ClassName, TBehavior Behavior)
	{
		TBehaviorTree Result = New('TBehaviorTree');
		Result.ChangeStatNum(STAT_INFO);
		Result.ClassName = ClassName;
		Result.Behavior = Behavior;
		return Result;
	}
}

class TBehaviorTreeManager: Thinker
{
	Array<TBehaviorTree> BehaviorTrees;
	static TBehaviorTreeManager Create()
	{
		TBehaviorTreeManager BehaviorTreeManager = New('TBehaviorTreeManager');
		BehaviorTreeManager.ChangeStatNum(STAT_INFO);
		return BehaviorTreeManager;
	}
	static TBehaviorTreeManager GetInstance()
	{
		ThinkerIterator Iterator = ThinkerIterator.Create('TBehaviorTreeManager', STAT_INFO);
		let Result = TBehaviorTreeManager(Iterator.Next());
		if (!Result)
			Result = TBehaviorTreeManager.Create();
		return Result;
	}
	int SearchBehavior(Class<TCustomCyberActor> ClassName)
	{
		for (int I = 0; I < BehaviorTrees.Size(); I++)
			if (BehaviorTrees[I].ClassName == ClassName)
				return I;
		// Not found.
		return -1;
	}
	void AddBehavior(Class<TCustomCyberActor> ClassName, TBehavior Behavior)
	{
		int Index = SearchBehavior(ClassName);
		if (Index < 0)
		{
			TBehaviorTree BehaviorTree = TBehaviorTree.Create(ClassName, Behavior);
			BehaviorTrees.Push(BehaviorTree);
		}
		else
			BehaviorTrees[Index].Behavior = Behavior;
	}
	TBehavior GetBehavior(Class<TCustomCyberActor> ClassName)
	{
		int Index = SearchBehavior(ClassName);
		if (Index >= 0)
			return BehaviorTrees[Index].Behavior;
		else
			return null;
	}
}

// -----------------------------------------------------------------------------
// The navigation agents inherits from KAI_Humanoid class.
// -----------------------------------------------------------------------------

enum TStrafeDirection
{
	StrafeRandom = -1, // Strafe in a random direction.
	StrafeNone = 0, // Don't strafe.
	StrafeLeft = 1, // Strafe left.
	StrafeRight = 2 // Strafe right.
}

// Chase mode
enum TChaseMode
{
	Walk,
	Run,
	RunFast
}

// -----------------------------------------------------------------------------
// Custom Cyber classes.
// -----------------------------------------------------------------------------

// Custom cyber actor.
class TCustomCyberActor : TCustomNavMeshActor
{
	// Link to other navigating agents.
	TNavMeshActors NavMeshActors;
	// Priority queue of targets.
	TPriorityQueue PriorityQueue;
	// Link to the cyber handler.
	TCyberEventHandler CyberEventHandler;
	// Behavior tree.
	TBehavior Behavior;
	StateLabel IdleState;
	StateLabel CurStateLabel;
	int CloackingTime;
	// Projectile dodging variables.
	bool Jumping;
	Actor NearbyProjectile;
	Actor PreviousProjectile;
	TStrafeDirection StrafeDirection;
	// Help variables.
	TCustomNavMeshActor HelpGiver;
	Actor HelpReceiver;
	// Chase behavior variables.
	int ChaseAttempts;
	double ChaseDetourFactor;
	int ChaseFlags;
	TChaseMode ChaseMode;
	TThreatLevel TargetThreatLevel;
	TExperiencedThreatLevel TargetExperiencedThreatLevel;
	bool TargetInSight;
	virtual void InitBehavior()
	{
		Behavior = null;
	}
	virtual void Initialize()
	{
		IdleState = "Idle";
		CurStateLabel = IdleState;
		HelpGiver = null;
		HelpReceiver = null;
		Jumping = false;
		NearbyProjectile = null;
		PreviousProjectile = null;
		TargetInSight = false;
	}
	override void OnDestroy()
	{
		if (NavMeshActors)
			NavMeshActors.RemoveMonster(self);
		super.OnDestroy();
	}
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		NavMeshActors = TNavMeshActors.GetInstance();
		if (NavMeshActors)
			NavMeshActors.AddMonster(self);
		PriorityQueue = TPriorityQueue.Create();
		CyberEventHandler = TCyberEventHandler(EventHandler.Find("TCyberEventHandler"));
		InitBehavior();
		Initialize();
	}
	override void Tick()
	{
		super.Tick();
		if ((Behavior) && (!IsFrozen()))
			Behavior.Think(self);
	}
	override Class<Actor> GetBloodType(int Type)
	{
		Class<Actor> Result;
		//CustomShield Shield = CustomShield(FindInventory('CustomShield', true));
		//if ((Shield) && (Shield.FShields > 0))
		//	Result = Shield.FShieldBloodType;
		//else
			Result = super.GetBloodType(Type);
		return Result;
	}
	static double Distance3DLine(Vector3 A, Vector3 B, Vector3 C)
	{
		return (((A - B) cross (C - B))).Length() / (C - B).Length();
	}
	// Checks if an enemy projectile, or one that should always be avoided, or a really harmful one, is approaching our direction.
	// The IgnoredProjectiles and AlwaysAvoid arrays can be used to list what projectiles should always avoid or ignore.
	bool FindNearbyProjectile(double Range = 384)
	{
		bool EpicFail; // Makes the function immediately stop running if the projectile is on the ignore list.
		Bool SkipAllyCheck;
		static const Name IgnoredProjectiles[] = // A list of enemy projectiles that they don't try avoiding.
		{
			"CyberBallSmall"
		};
		static const Name AlwaysAvoid[] = // A list of projectiles to always avoid, even if fired by a friend.
		{
			"LargeKiBall",
			"Rocket",
			"BFGBall"
		};
		if (KAIHandler)
		{
			for ( int I; I < KAIHandler.ProjectileList.Size(); I++ )
			{
				Actor Projectile = KAIHandler.ProjectileList[I];
				// Null check.
				if ( !Projectile )
					continue;
				// Out of range.
				if ( Distance3DSquared(Projectile) > Range * Range )
					continue;
				// Don't keep dodging the same projectile.
				if ( Projectile == PreviousProjectile )
					continue;
				// Don't return true if it's part of the blacklist.
				for ( int I; I < IgnoredProjectiles.Size(); I++ )
					if ( Projectile.GetClassName() == IgnoredProjectiles[I] )
					{
						EpicFail = true;
						continue;
					}
				if ( EpicFail )
					continue;
				// Hostile monsters will dodge all projectiles, except for ones on the Ignored Projectiles list.
				if ( !bFriendly )
					SkipAllyCheck = true;
				for ( int I; I < AlwaysAvoid.Size(); I++ )
					if ( Projectile.GetClassName() == AlwaysAvoid[I] )
					{
						SkipAllyCheck = true;
						continue;
					}
				if ( !SkipAllyCheck && Projectile.Target && !IsActorHostile(Projectile.Target) )
					continue;
				// Don't return true if the projectile isn't visible at all, or is too far away from peripheral vision. Or if it isn't so close that it's impossible not to notice it.
				if ( !(IsVisible(Projectile, True) && (AbsAngle(Angle, AngleTo(Projectile)) < 120.0 || !(Distance3DSquared(Projectile) > Range * Range / 6))) )
					continue;
				// Is the projectile about to hit me ? Weird math nonsense written by RaveYard.
				bool IsProjectileFlyingTowardsMe = (Vec3To(Projectile).Unit() dot Projectile.vel.Unit()) < -0.15;
				double ProjectileSafeRadius = Sqrt(2 * ((Projectile.Radius + Radius) ** 2.2));
				if ( IsProjectileFlyingTowardsMe && Distance3DLine(Pos, Projectile.Pos, Projectile.Pos + Projectile.Vel) < ProjectileSafeRadius )
				{
					NearbyProjectile = Projectile;
					return true;
				}
			}
		}
		return false;
	}
	// Checks what directions will be able to jump to, to avoid any incoming projectiles.
	// This (mostly) prevents from jumping into walls or off very tall ledges.
	bool ShouldDodgeProjectile(double Distance = 512)
	{
		bool LeftSafe;
		bool RightSafe;
		double OldAngle;
		if ( FindNearbyProjectile(Distance) )
		{
			OldAngle = Angle; // Store the current angle before facing the projectile to dodge it.
			MaxDropOffHeight = 128; // Temporarily increase the maximum height can drop from.
			A_Face(NearbyProjectile, flags:FAF_MIDDLE);
			// Check if it's safe to strafe 64 map units to the left or right, or both. Or none even, like in the case of crammed corridors.
			LeftSafe = CheckMove(Vec2Angle(64, Angle + 90), PCM_DROPOFF);
			RightSafe = CheckMove(Vec2Angle(64, Angle - 90), PCM_DROPOFF);
			if ( (LeftSafe && RightSafe) ) //Both directions are safe to strafe to.
				StrafeDirection = StrafeRandom;
			else
				if ( (!LeftSafe && !RightSafe) ) // The area is too crammed to strafe anywhere here.
				{
					Angle = OldAngle; // Revert the angle if you can't dodge.
					StrafeDirection = StrafeNone; // Reset the strafe direction to none.
					MaxDropOffHeight = default.MaxDropOffHeight; // Revert the property to the default again.
					return false; // Don't break whatever state sequence is currently in to tell him he can't dodge.
				}
				else
					if ( LeftSafe && !RightSafe ) // Can only strafe left.
						StrafeDirection = StrafeLeft;
					else
						if ( !LeftSafe && RightSafe ) // Can only strafe right.
							StrafeDirection = StrafeRight;
			MaxDropOffHeight = default.MaxDropOffHeight; // Revert the property to the default again.
			return true; // Found a direction to strafe at to dodge.
		}
		StrafeDirection = StrafeNone;
		return false; // Didn't even find a projectile to dodge.
	}
	// Move towards the destination.
	void MoveTowards(Vector3 Destination)
	{
		KAI_Chase_PreChecks(ChaseFlags);
		KAI_MoveTowards(Destination, ChaseDetourFactor, 0, 0, ChaseFlags);
	}
	// Move away from the destination.
	void MoveAway(Vector3 Destination)
	{
		KAI_Chase_PreChecks(ChaseFlags);
		KAI_MoveAway(Target, ChaseAttempts, 128, 32, ChaseDetourFactor, 0, 0, ChaseFlags);
	}
	// State machine update.
	void B_SetStateLabel(StateLabel AStateLabel)
	{
		if (CurStateLabel == AStateLabel)
			return;
		if (
				(CurStateLabel == 'Idle')
				&& ((AStateLabel == 'Walk') || (AStateLabel == 'Run') || (AStateLabel == 'RunFast'))
				&& (SeeSound)
				&& (Health > 0)
				&& (Target)
			)
			A_StartSound(SeeSound, CHAN_VOICE, CHANF_DEFAULT, 1.0, bBoss ? ATTN_NONE : ATTN_NORM);
		CurStateLabel = AStateLabel;
		SetStateLabel(CurStateLabel);
	}
	virtual void B_Think()
	{
		SetStateLabel(CurStateLabel);
	}
	// Searches for any hostile target and manage the priority queue.
	void B_Look(double PlayerRange = 4096)
	{
		// Remove dead actors from the priority queue.
		bool ListChanged;
		do
		{
			ListChanged = false;
			for (int I = 0; I < PriorityQueue.ItemsCount; I++)
			{
				// Remove monsters removed from the global handler.
				int Index = CyberEventHandler.MonsterList.Find(PriorityQueue.Items[I].Monster);
				if ((Index == CyberEventHandler.MonsterList.Size()) && !(PriorityQueue.Items[I].Monster is 'PlayerPawn'))
				{
					PriorityQueue.Remove(I);
					ListChanged = true;
					break;
				}
				// Remove monsters or players with zero health.
				if (PriorityQueue.Items[I].Monster.Health <= 0)
				{
					PriorityQueue.Remove(I);
					ListChanged = true;
					break;
				}
				// Remove monsters with ETL_INITIAL experience.
				if (PriorityQueue.Items[I].ExperiencedThreatLevel == ETL_INITIAL)
					if (PriorityQueue.Items[I].Timer > 0)
						PriorityQueue.Items[I].Timer--;
					else
					{
						PriorityQueue.Remove(I);
						ListChanged = true;
						break;
					}
			}
		} while (ListChanged);
		// Update the threat level.
		for (int I = 0; I < PriorityQueue.ItemsCount; I++)
		{
			TExperiencedThreatLevel ExperiencedThreatLevel = PriorityQueue.Items[I].ExperiencedThreatLevel;
			if (CyberEventHandler.IsDangerous(PriorityQueue.Items[I].Monster.GetClass()))
				ExperiencedThreatLevel = ETL_DANGER;
			if (CyberEventHandler.IsCritical(PriorityQueue.Items[I].Monster.GetClass()))
				ExperiencedThreatLevel = ETL_CRITICAL;
			TThreatLevel ThreatLevel = AssessThreatLevel(PriorityQueue.Items[I].Monster);
			PriorityQueue.UpdatePriority(PriorityQueue.Items[I].Monster, ThreatLevel, ExperiencedThreatLevel);
		}
		// Check that there are any alive nearby players currently in the game.
		double RangeSquared = PlayerRange ** 2;
		for (int I = 0; I < Players.Size(); ++I)
			if (PlayerInGame[I] && Players[I].mo.Health > 0 && IsActorHostile(Players[I].mo) && CheckSight(Players[I].mo))
			{
				TThreatLevel ThreatLevel = AssessThreatLevel(Players[I].mo);
				TExperiencedThreatLevel ExperiencedThreatLevel = ETL_INITIAL;
				int Index = PriorityQueue.Find(Players[I].mo);
					if (Index >= 0)
						PriorityQueue.UpdatePriority(Players[I].mo, ThreatLevel, PriorityQueue.Items[Index].ExperiencedThreatLevel);
					else
						PriorityQueue.Insert(Players[I].mo, ThreatLevel, ExperiencedThreatLevel);
			}
		if (CyberEventHandler)
			for (int I = 0; I < CyberEventHandler.MonsterList.Size(); I++)
				if (CheckSight(CyberEventHandler.MonsterList[I]))
				{
					Actor Monster = CyberEventHandler.MonsterList[I];
					if (IsActorHostile(Monster) && !IsDead(Monster))
					{
						TThreatLevel ThreatLevel = AssessThreatLevel(Monster);
						TExperiencedThreatLevel ExperiencedThreatLevel = ETL_INITIAL;
						int Index = PriorityQueue.Find(Monster);
						if (Index >= 0)
							PriorityQueue.UpdatePriority(Monster, ThreatLevel, PriorityQueue.Items[Index].ExperiencedThreatLevel);
						else
							PriorityQueue.Insert(Monster, ThreatLevel, ExperiencedThreatLevel);
					}
				}
	}
	void B_Chase(Vector3 Destination)
	{
		if (Target)
		{
			if (CheckSight(Target))
			{
				if (RouteActive)
					RouteEnd();
				MoveTowards(Destination);
			}
			else
			{
				if (NavMesh)
					if (RouteActive)
						RouteChase(Destination);
					else
					{
						if (RouteSearch(Destination))
						{
							RouteBegin();
							RouteChase(Destination);
						}
						else
							MoveTowards(Destination);
					}
				else
					MoveTowards(Destination);
			}
		}
	}
	virtual void B_Die()
	{
		A_ScreamAndUnblock();
		ResuscitationTimer = 120 * TICRATE;
	}
	void B_DisableCloackingDevice()
	{
		A_SetRenderStyle(1.00, STYLE_Normal);
		bSHADOW = false;
	}
	void B_EnableCloackingDevice()
	{
		if (GetRenderStyle() == STYLE_Normal)
			A_StartSound("Shield/CloackingDevice", CHAN_ITEM, CHANF_DEFAULT);
		A_SetRenderStyle(0.25, STYLE_Translucent);
		bSHADOW = true;
		CloackingTime = 70;
	}
	void SpawnParticles(double Angle, double Pitch)
	{
		Vector3 StartPoint = Pos;
		StartPoint.Z += Height * 0.80;
		FLineTracedata LineTraceData;
		LineTrace(Angle, PLAYERMISSILERANGE, Pitch, 0, StartPoint.Z, 0, 0, LineTraceData);
		Vector3 StopPoint = LineTraceData.HitLocation;
		Vector3 Diff = Level.Vec3Diff(StartPoint, StopPoint);
		Vector3 Dir = Diff.Unit();
		double Dist = Diff.Length();
		double PartDist = 1;
		double PartSteps = int(Dist / PartDist);
		vector3 NextPos = StartPoint;
		FSpawnParticleParams TraceParticle;
		TraceParticle.Color1 = "FFFFA0";
		TraceParticle.LifeTime = 4;
		TraceParticle.Size = 4;
		TraceParticle.StartAlpha = 1;
		TraceParticle.Flags = SPF_FULLBRIGHT | SPF_NOTIMEFREEZE;
		for (int I = 1; I <= PartSteps; I++)
		{
			TraceParticle.Pos = NextPos;
			Level.SpawnParticle(TraceParticle);
			NextPos += Dir * PartDist;
		}
	}
	void B_CyberRifleAttack()
	{
		AimAtTarget();
		A_StartSound("weapons/cr");
		int Damage = 32 + 4 * Random(0, 8);
		A_CustomBulletAttack(1.125, 0, 1, Damage);
		SpawnParticles(Angle, Pitch);
	}
	void B_SuperCyberRifleAttack()
	{
		AimAtTarget();
		A_StartSound("weapons/scr");
		for (int I = 0; I < 24; I++)
		{
			int Damage = 32 + 4 * Random(0, 8);
			A_CustomBulletAttack(1.125, 0, 1, Damage);
			SpawnParticles(Angle, Pitch);
		}
	}
	default
	{
		Species "CyberActor";
	}
}

// Basic behavior of custom cyber actor.
class TCyberBasic : TCustomCyberActor
{
	override int DamageMobj(Actor Inflictor, Actor Source, int Damage, Name Mod, int Flags, double Angle)
	{
		int NewDamage = super.DamageMobj(Inflictor, Source, Damage, Mod, Flags, Angle);
		if ( (Source) && (IsActorHostile(Source)) && (Health > 0) )
		{
			int MonsterIndex = PriorityQueue.Find(Source);
			if (MonsterIndex < 0)
			{
				PriorityQueue.Insert(Source, AssessThreatLevel(Source), ETL_INITIAL);
				MonsterIndex = PriorityQueue.Find(Source);
			}
			PriorityQueue.Items[MonsterIndex].TotalDamage += NewDamage;
			TThreatLevel ThreatLevel = AssessThreatLevel(Source);
			TExperiencedThreatLevel ExperiencedThreatLevel = ETL_NORMAL;
			if (Damage > 149)
			{
				CyberEventHandler.AddDangerousClass(Source.GetClass());
				ExperiencedThreatLevel = ETL_DANGER;
			}
			if (Damage > 499)
			{
				CyberEventHandler.AddCriticalClass(Source.GetClass());
				ExperiencedThreatLevel = ETL_CRITICAL;
			}
			PriorityQueue.UpdatePriority(Source, ThreatLevel, ExperiencedThreatLevel);
		}
		return NewDamage;
	}
}

// A cyber actor with a strong armor, that absorbs all damage below 10.
class TCyberAdvanced : TCustomCyberActor
{
	override int DamageMobj(Actor Inflictor, Actor Source, int Damage, Name Mod, int Flags, double Angle)
	{
		if ( Damage < 10 )
			Damage = 0;
		int NewDamage = super.DamageMobj(Inflictor, Source, Damage, Mod, Flags, Angle);
		if ( (Source) && (IsActorHostile(Source)) && (Health > 0) )
		{
			int MonsterIndex = PriorityQueue.Find(Source);
			if ((MonsterIndex < 0) && (IsActorHostile(Source)))
			{
				PriorityQueue.Insert(Source, AssessThreatLevel(Source), ETL_INITIAL);
				MonsterIndex = PriorityQueue.Find(Source);
			}
			PriorityQueue.Items[MonsterIndex].TotalDamage += NewDamage;
			TThreatLevel ThreatLevel = AssessThreatLevel(Source);
			TExperiencedThreatLevel ExperiencedThreatLevel = ETL_NORMAL;
			if (Damage > 149)
			{
				CyberEventHandler.AddDangerousClass(Source.GetClass());
				ExperiencedThreatLevel = ETL_DANGER;
			}
			if (Damage > 499)
			{
				CyberEventHandler.AddCriticalClass(Source.GetClass());
				ExperiencedThreatLevel = ETL_CRITICAL;
			}
			PriorityQueue.UpdatePriority(Source, ThreatLevel, ExperiencedThreatLevel);
		}
		return NewDamage;
	}
	override bool SpecialBlastHandling(Actor Source, double Strength)
	{
		return false;
	}
	default
	{
		DamageFactor "BFGSplash", 0;
		+Boss;
		+DontBlast;
		+DontDrain;
		+DontGib;
		+DontMorph;
		+DontRip;
		+FloorClip;
		+NoRadiusDmg;
		+SeeInvisible;
	}
}

// -----------------------------------------------------------------------------
// Event handler.
// -----------------------------------------------------------------------------

// Give aid to other cyber actors, for nurses and medics AI.
class TCyberBasic_AINode_GiveAid : TBehavior
{
	static TCyberBasic_AINode_GiveAid Create()
	{
		TCyberBasic_AINode_GiveAid Result = New('TCyberBasic_AINode_GiveAid');
		return Result;
	}
	override TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		if (CustomCyberActor.HelpReceiver)
		{
			TCustomCyberActor CastHelpReceiver = TCustomCyberActor(CustomCyberActor.HelpReceiver);
			if (!CastHelpReceiver)
				CustomCyberActor.HelpReceiver = null;
			else
				if ((CastHelpReceiver.Health <= 0) && (CastHelpReceiver.ResuscitationTimer == 0))
					CustomCyberActor.HelpReceiver = null;
		}
		if (!CustomCyberActor.HelpReceiver)
		{
			TNavMeshActors NavMeshActors = CustomCyberActor.CyberEventHandler.NavMeshActors;
			for (int I = 0; I < NavMeshActors.NavMeshActors.Size(); I++)
			{
				TCustomNavMeshActor CustomNavMeshActor = NavMeshActors.NavMeshActors[I];
				if ((!CustomCyberActor.IsActorHostile(CustomNavMeshActor)) && ((CustomNavMeshActor.Health * 5) < CustomNavMeshActor.default.Health))
				{
					if ((CustomNavMeshActor.Health <= 0) && (CustomNavMeshActor.ResuscitationTimer == 0))
						continue;
					if ((CustomCyberActor.bNavMeshNurse) && (CustomNavMeshActor.Health <= 0))
						continue;
					if ((CustomCyberActor.NavMesh) && (CustomCyberActor.CheckSight(CustomNavMeshActor)))
					{
						CustomCyberActor.HelpReceiver = CustomNavMeshActor;
						break;
					}
					else
						if (CustomCyberActor.RouteSearch(CustomNavMeshActor.Pos))
						{
							CustomCyberActor.HelpReceiver = CustomNavMeshActor;
							break;
						}
				}
			}
		}
		if (CustomCyberActor.HelpReceiver)
		{
			CustomCyberActor.ChaseMode = Run;
			CustomCyberActor.ChaseAttempts = 32;
			CustomCyberActor.ChaseDetourFactor = 1;
			CustomCyberActor.ChaseFlags = 0;
			CustomCyberActor.Speed = CustomCyberActor.default.Speed * 2;
			CustomCyberActor.B_SetStateLabel("Run");
			if (CustomCyberActor.CheckSight(CustomCyberActor.HelpReceiver))
			{
				if (CustomCyberActor.RouteActive)
					CustomCyberActor.RouteEnd();
				CustomCyberActor.MoveTowards(CustomCyberActor.HelpReceiver.Pos);
			}
			else
			{
				if (CustomCyberActor.NavMesh)
					if (CustomCyberActor.RouteActive)
						CustomCyberActor.RouteChase(CustomCyberActor.HelpReceiver.Pos);
					else
					{
						if (CustomCyberActor.RouteSearch(CustomCyberActor.HelpReceiver.Pos))
						{
							CustomCyberActor.RouteBegin();
							CustomCyberActor.RouteChase(CustomCyberActor.HelpReceiver.Pos);
						}
						else
							CustomCyberActor.MoveTowards(CustomCyberActor.HelpReceiver.Pos);
					}
				else
					CustomCyberActor.MoveTowards(CustomCyberActor.HelpReceiver.Pos);
			}
			int Distance = CustomCyberActor.Distance2D(CustomCyberActor.HelpReceiver) - CustomCyberActor.Radius - CustomCyberActor.HelpReceiver.Radius;
			if (Distance <= CustomCyberActor.MeleeRange)
			{
				CustomCyberActor.B_SetStateLabel("Help");
				if (CustomCyberActor.HelpReceiver.Health <= 0)
				{
					bool IsFriendly = CustomCyberActor.HelpReceiver.bFriendly;
					CustomCyberActor.RaiseActor(CustomCyberActor.HelpReceiver);
					CustomCyberActor.HelpReceiver.bFriendly = IsFriendly;
					return BH_SUCCESS;
				}
				else
				{
					CustomCyberActor.HelpReceiver.Health += 5;
					if (CustomCyberActor.HelpReceiver.Health >= CustomCyberActor.HelpReceiver.default.Health)
					{
						CustomCyberActor.HelpReceiver.Health = CustomCyberActor.HelpReceiver.default.Health;
						CustomCyberActor.HelpReceiver = null;
					}
					return BH_SUCCESS;
				}
			}
			return BH_RUNNING;
		}
		return BH_SUCCESS;
	}
}

// Repairing vehicles AI.
class TCyberBasic_AINode_RepairVehicles : TBehavior
{
	static TCyberBasic_AINode_RepairVehicles Create()
	{
		TCyberBasic_AINode_RepairVehicles Result = New('TCyberBasic_AINode_RepairVehicles');
		return Result;
	}
	override TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		if ((CustomCyberActor.HelpReceiver) && (CustomCyberActor.HelpReceiver.Health <= 0))
			CustomCyberActor.HelpReceiver = null;
		if (!CustomCyberActor.HelpReceiver)
		{
			for (int I = 0; I < CustomCyberActor.KAIHandler.AllVehicles.Size(); I++)
			{
				KAI_BaseVehicle Vehicle = CustomCyberActor.KAIHandler.AllVehicles[I];
				if ((!CustomCyberActor.IsActorHostile(Vehicle)) && (Vehicle.Health * 5) < Vehicle.default.Health)
				{
					CustomCyberActor.HelpReceiver = Vehicle;
					break;
				}
			}
		}
		if (CustomCyberActor.HelpReceiver)
		{
			CustomCyberActor.ChaseMode = Walk;
			CustomCyberActor.ChaseAttempts = 32;
			CustomCyberActor.ChaseDetourFactor = 1;
			CustomCyberActor.ChaseFlags = 0;
			CustomCyberActor.Speed = CustomCyberActor.default.Speed;
			CustomCyberActor.B_SetStateLabel("Walk");
			if (CustomCyberActor.CheckSight(CustomCyberActor.HelpReceiver))
			{
				if (CustomCyberActor.RouteActive)
					CustomCyberActor.RouteEnd();
				CustomCyberActor.MoveTowards(CustomCyberActor.HelpReceiver.Pos);
			}
			else
			{
				if (CustomCyberActor.NavMesh)
					if (CustomCyberActor.RouteActive)
						CustomCyberActor.RouteChase(CustomCyberActor.HelpReceiver.Pos);
					else
					{
						if (CustomCyberActor.RouteSearch(CustomCyberActor.HelpReceiver.Pos))
						{
							CustomCyberActor.RouteBegin();
							CustomCyberActor.RouteChase(CustomCyberActor.HelpReceiver.Pos);
						}
						else
							CustomCyberActor.MoveTowards(CustomCyberActor.HelpReceiver.Pos);
					}
				else
					CustomCyberActor.MoveTowards(CustomCyberActor.HelpReceiver.Pos);
			}
			int Distance = CustomCyberActor.Distance2D(CustomCyberActor.HelpReceiver) - CustomCyberActor.Radius - CustomCyberActor.HelpReceiver.Radius;
			if (Distance <= CustomCyberActor.MeleeRange)
			{
				CustomCyberActor.B_SetStateLabel("RepairVehicle");
				CustomCyberActor.HelpReceiver.Health += 5;
				if (CustomCyberActor.HelpReceiver.Health >= CustomCyberActor.HelpReceiver.default.Health)
				{
					CustomCyberActor.HelpReceiver.Health = CustomCyberActor.HelpReceiver.default.Health;
					CustomCyberActor.HelpReceiver = null;
					return BH_SUCCESS;
				}
			}
			return BH_RUNNING;
		}
		return BH_SUCCESS;
	}
}

// Safety check before firing a hitscan weapon.
class TCyberBasic_AINode_SafeHitscan : TBehavior
{
	static TCyberBasic_AINode_SafeHitscan Create()
	{
		TCyberBasic_AINode_SafeHitscan Result = New('TCyberBasic_AINode_SafeHitscan');
		return Result;
	}
	override TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		if (CustomCyberActor.Target)
		{
			CustomCyberActor.A_FaceTarget();
			/*FLineTraceData LineTraceData;
			CustomCyberActor.LineTrace(CustomCyberActor.Angle, PLAYERMISSILERANGE, CustomCyberActor.Pitch, 0, CustomCyberActor.Height * 0.9, 0, 0, LineTraceData);
			if (!CustomCyberActor.IsActorHostile(LineTraceData.HitActor))
				return BH_FAILURE;
			return BH_SUCCESS;*/
			KAI_LOFActorFinder Check = New('KAI_LOFActorFinder');
			Check.ActorLimit = 0;
			Check.BlockMode = KAI_LOFRaycast.BLITW_HitscansOnly;
			Check.Other = CustomCyberActor.Target;
			Check.Shooter = CustomCyberActor;
			Vector3 CheckOffsets = (0, 0, 32);
			Vector3 Direction = (CustomCyberActor.AngleToVector(CustomCyberActor.Angle, Cos(CustomCyberActor.Pitch)), -Sin(CustomCyberActor.Pitch));
			Check.Trace(Level.Vec3Offset(CustomCyberActor.Pos, CheckOffsets), CustomCyberActor.CurSector, Direction, PLAYERMISSILERANGE, 0);
			TStatus Status = BH_SUCCESS;
			foreach (HitActor : Check.Mobjs)
			{
				if ((!CustomCyberActor.IsActorHostile(HitActor)) && (!CustomCyberActor.IsDead(HitActor)))
				{
					Status = BH_FAILURE;
					break;
				}
			}
			Check.Destroy();
			return Status;
		}
		else
			return BH_FAILURE;
	}
}

// Looks for enemies.
class TCyberBasic_AINode_SeekGoal : TBehavior
{
	static TCyberBasic_AINode_SeekGoal Create()
	{
		TCyberBasic_AINode_SeekGoal Result = New('TCyberBasic_AINode_SeekGoal');
		return Result;
	}
	override TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		CustomCyberActor.B_Look();
		if (CustomCyberActor.PriorityQueue.ItemsCount > 0)
		{
			CustomCyberActor.Target = CustomCyberActor.PriorityQueue.Items[0].Monster;
			CustomCyberActor.TargetThreatLevel = CustomCyberActor.PriorityQueue.Items[0].ThreatLevel;
			CustomCyberActor.TargetExperiencedThreatLevel = CustomCyberActor.PriorityQueue.Items[0].ExperiencedThreatLevel;
			CustomCyberActor.TargetInSight = CustomCyberActor.CheckSight(CustomCyberActor.Target);
		}
		else
		{
			CustomCyberActor.A_ClearTarget();
			CustomCyberActor.B_SetStateLabel(CustomCyberActor.IdleState);
		}
		return BH_SUCCESS;
	}
}

// Looks for help.
class TCyberBasic_AINode_SeekHelp : TBehavior
{
	double HealthScore;
	static TCyberBasic_AINode_SeekHelp Create(double HealthScore = 0)
	{
		TCyberBasic_AINode_SeekHelp Result = New('TCyberBasic_AINode_SeekHelp');
		Result.HealthScore = HealthScore;
		return Result;
	}
	override TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		if (CustomCyberActor.Health < HealthScore)
		{
			if ((CustomCyberActor.HelpGiver) && (CustomCyberActor.HelpGiver.Health <= 0))
				CustomCyberActor.HelpGiver = null;
			if (!CustomCyberActor.HelpGiver)
			{
				// Search the nearest medic or nurse.
				TNavMeshActors NavMeshActors = CustomCyberActor.CyberEventHandler.NavMeshActors;
				for (int I = 0; I < NavMeshActors.NavMeshActors.Size(); I++)
				{
					TCustomNavMeshActor CustomNavMeshActor = NavMeshActors.NavMeshActors[I];
					if (CustomNavMeshActor.bNavMeshMedic || CustomNavMeshActor.bNavMeshNurse)
					{
						if ((CustomCyberActor.NavMesh) && (CustomCyberActor.CheckSight(CustomNavMeshActor)))
						{
							CustomCyberActor.HelpGiver = CustomNavMeshActor;
							break;
						}
						else
							if (CustomCyberActor.RouteSearch(CustomNavMeshActor.Pos))
							{
								CustomCyberActor.HelpGiver = CustomNavMeshActor;
								break;
							}
					}
				}
			}
			if (CustomCyberActor.HelpGiver)
			{
				CustomCyberActor.ChaseMode = Run;
				CustomCyberActor.ChaseAttempts = 32;
				CustomCyberActor.ChaseDetourFactor = 1;
				CustomCyberActor.ChaseFlags = 0;
				CustomCyberActor.Speed = CustomCyberActor.default.Speed * 2;
				CustomCyberActor.B_SetStateLabel("Run");
				if (CustomCyberActor.CheckSight(CustomCyberActor.HelpGiver))
				{
					if (CustomCyberActor.RouteActive)
						CustomCyberActor.RouteEnd();
					CustomCyberActor.MoveTowards(CustomCyberActor.HelpGiver.Pos);
				}
				else
				{
					if (CustomCyberActor.NavMesh)
						if (CustomCyberActor.RouteActive)
							CustomCyberActor.RouteChase(CustomCyberActor.HelpGiver.Pos);
						else
						{
							if (CustomCyberActor.RouteSearch(CustomCyberActor.HelpGiver.Pos))
							{
								CustomCyberActor.RouteBegin();
								CustomCyberActor.RouteChase(CustomCyberActor.HelpGiver.Pos);
							}
							else
								CustomCyberActor.MoveTowards(CustomCyberActor.HelpGiver.Pos);
						}
					else
						CustomCyberActor.MoveTowards(CustomCyberActor.HelpGiver.Pos);
				}
				return BH_RUNNING;
			}
			else
				return BH_SUCCESS;
		}
		else
			return BH_SUCCESS;
	}
}

// Looks for incoming projectiles.
class TCyberBasic_AINode_SeekIncoming : TBehavior
{
	static TCyberBasic_AINode_SeekIncoming Create()
	{
		TCyberBasic_AINode_SeekIncoming Result = New('TCyberBasic_AINode_SeekIncoming');
		return Result;
	}
	void DodgeStrafing(TCustomCyberActor CustomCyberActor)
	{
		switch (CustomCyberActor.StrafeDirection)
		{
			case StrafeRandom:
				int Direction = Random(1, 3) - 2;
				CustomCyberActor.A_ChangeVelocity(
						8 * Direction,
						8 * Direction,
						0,
						CVF_RELATIVE
				);
				break;
			case StrafeNone:
				CustomCyberActor.A_ChangeVelocity(-8, 0, 0, CVF_RELATIVE);
				break;
			case StrafeLeft:
				CustomCyberActor.A_ChangeVelocity(0, 8, 0, CVF_RELATIVE);
				break;
			case StrafeRight:
				CustomCyberActor.A_ChangeVelocity(0, -8, 0, CVF_RELATIVE);
				break;
		}
	}
	override TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		if (CustomCyberActor.InStateSequence(CustomCyberActor.CurState, CustomCyberActor.ResolveState("Jump")))
			return BH_RUNNING;
		else
			CustomCyberActor.Jumping = false;
		if (CustomCyberActor.ShouldDodgeProjectile())
		{
			if (CustomCyberActor.IsInAttackState())
				DodgeStrafing(CustomCyberActor);
			else
				if (CustomCyberActor.FindState("Jump"))
					CustomCyberActor.SetStateLabel("Jump");
				else
					DodgeStrafing(CustomCyberActor);
			return BH_RUNNING;
		}
		return BH_SUCCESS;
	}
}

// Chasing AI.
class TCyberBasic_AINode_Chase : TBehavior
{
	double ChaseDistance;
	bool MoveInAttackState;
	int RunSpeed;
	int WalkSpeed;
	static TCyberBasic_AINode_Chase Create(double ChaseDistance = 0, int RunSpeed = 0, int WalkSpeed = 0, bool MoveInAttackState = true)
	{
		TCyberBasic_AINode_Chase Result = New('TCyberBasic_AINode_Chase');
		Result.ChaseDistance = ChaseDistance;
		Result.MoveInAttackState = MoveInAttackState;
		Result.RunSpeed = RunSpeed;
		Result.WalkSpeed = WalkSpeed;
		return Result;
	}
	override TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		if (CustomCyberActor.Target)
		{
			bool InAttackState = CustomCyberActor.IsInAttackState();
			bool MoveTowardsTarget;
			if (
					(CustomCyberActor.IsIndestructible(CustomCyberActor.Target))
					|| (CustomCyberActor.HasGodMode(CustomCyberActor.Target))
					|| (CustomCyberActor.HasBuddha(CustomCyberActor.Target))
					|| (CustomCyberActor.IsFrightening(CustomCyberActor.Target))
				)
			{
				// A no win scenario: simply run away.
				CustomCyberActor.ChaseMode = Run;
				CustomCyberActor.ChaseAttempts = 32;
				CustomCyberActor.ChaseDetourFactor = 0.5;
				CustomCyberActor.ChaseFlags = 0;
				CustomCyberActor.Speed = RunSpeed;
				if (!InAttackState)
					CustomCyberActor.B_SetStateLabel("Run");
				MoveTowardsTarget = false;
			}
			else
				if (
						(CustomCyberActor.TargetExperiencedThreatLevel == ETL_CRITICAL)
						|| (CustomCyberActor.TargetThreatLevel > CustomCyberActor.ThreatLevelThreshold)
						|| (CustomCyberActor.bFrightened)
					)
				{
					// Try to run away from this target.
					CustomCyberActor.ChaseMode = Run;
					CustomCyberActor.ChaseAttempts = 32;
					CustomCyberActor.ChaseDetourFactor = 1;
					CustomCyberActor.ChaseFlags = 0;
					CustomCyberActor.Speed = RunSpeed;
					if (!InAttackState)
						CustomCyberActor.B_SetStateLabel("Run");
					MoveTowardsTarget = false;
				}
				else
					if (
							(CustomCyberActor.TargetExperiencedThreatLevel == ETL_DANGER)
							|| (CustomCyberActor.TargetThreatLevel == CustomCyberActor.ThreatLevelThreshold)
						)
					{
						CustomCyberActor.ChaseMode = Run;
						CustomCyberActor.ChaseAttempts = 32;
						CustomCyberActor.ChaseDetourFactor = 1;
						CustomCyberActor.ChaseFlags = CustomCyberActor.KMT_ZIGZAG;
						CustomCyberActor.Speed = RunSpeed;
						if (!InAttackState)
							CustomCyberActor.B_SetStateLabel("Run");
						MoveTowardsTarget = true;
					}
					else
					{
						CustomCyberActor.ChaseMode = Walk;
						CustomCyberActor.ChaseAttempts = 32;
						CustomCyberActor.ChaseDetourFactor = 1;
						CustomCyberActor.ChaseFlags = CustomCyberActor.KMT_ZIGZAG;
						CustomCyberActor.Speed = WalkSpeed;
						if (!InAttackState)
							CustomCyberActor.B_SetStateLabel("Walk");
						MoveTowardsTarget = true;
					}
			if (!((InAttackState) && (!MoveInAttackState)))
				if (MoveTowardsTarget)
					if (CustomCyberActor.Distance2D(CustomCyberActor.Target) > ChaseDistance)
						CustomCyberActor.B_Chase(CustomCyberActor.Target.Pos);
					else
						CustomCyberActor.MoveAway(CustomCyberActor.Target.Pos);
				else
					CustomCyberActor.MoveAway(CustomCyberActor.Target.Pos);
			return BH_SUCCESS;
		}
		else
			return BH_FAILURE;
	}
}

// Fighting AI.
class TCyberBasic_AINode_Fight : TBehavior
{
	int LowHealth;
	static TCyberBasic_AINode_Fight Create(int LowHealth = 0)
	{
		TCyberBasic_AINode_Fight Result = New('TCyberBasic_AINode_Fight');
		Result.LowHealth = LowHealth;
		return Result;
	}
	override TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		if (CustomCyberActor.IsInAttackState())
		{
			CustomCyberActor.A_FaceTarget();
			return BH_RUNNING;
		}
		if (CustomCyberActor.Target)
		{
			Actor Target = CustomCyberActor.Target;
			bool FitForFight;
			if (
					(CustomCyberActor.IsIndestructible(CustomCyberActor.Target))
					|| (CustomCyberActor.HasGodMode(CustomCyberActor.Target))
					|| (CustomCyberActor.HasBuddha(CustomCyberActor.Target))
				)
				// A no win scenario: don't attack, avoid getting engaged in a fight.
				FitForFight = false;
			else
				if (CustomCyberActor.TargetThreatLevel > CustomCyberActor.ThreatLevelThreshold)
				{
					if (CustomCyberActor.Health < LowHealth)
						// Too risky to get engaged in a fight.
						FitForFight = false;
					else
						FitForFight = true;
				}
				else
					FitForFight = true;
			if (FitForFight)
			{
				if ((CustomCyberActor.MeleeState) && (CustomCyberActor.KAI_CheckMeleeRange(Target)))
					CustomCyberActor.SetState(CustomCyberActor.MeleeState);
				else
					if ((CustomCyberActor.MissileState) && (CustomCyberActor.KAI_CheckMissileRange(Target, true)))
						CustomCyberActor.SetState(CustomCyberActor.MissileState);
			}
			return BH_SUCCESS;
		}
		else
			return BH_FAILURE;
	}
}

// Fighting AI.
class TCyberAdvanced_AINode_Fight : TBehavior
{
	int LowHealth;
	static TCyberAdvanced_AINode_Fight Create(int LowHealth = 0)
	{
		TCyberAdvanced_AINode_Fight Result = New('TCyberAdvanced_AINode_Fight');
		Result.LowHealth = LowHealth;
		return Result;
	}
	override TStatus Update(TCustomCyberActor CustomCyberActor)
	{
		if (CustomCyberActor.IsInAttackState())
		{
			CustomCyberActor.A_FaceTarget();
			return BH_RUNNING;
		}
		if (CustomCyberActor.Target)
		{
			Actor Target = CustomCyberActor.Target;
			bool FitForFight = true;
			bool PerformMelee = false;
			double MeleeFuzzy;
			if (
					(CustomCyberActor.IsIndestructible(CustomCyberActor.Target))
					|| (CustomCyberActor.HasGodMode(CustomCyberActor.Target))
					|| (CustomCyberActor.HasBuddha(CustomCyberActor.Target))
				)
				// A no win scenario: don't attack, avoid getting engaged in a fight.
				FitForFight = false;
			else
				switch (CustomCyberActor.TargetExperiencedThreatLevel)
				{
					case ETL_CRITICAL:
						FitForFight = false;
						break;
					case ETL_DANGER:
						if (CustomCyberActor.Health < LowHealth)
							// Too risky to get engaged in a fight.
							FitForFight = false;
						else
							FitForFight = true;
						break;
					default:
						switch (CustomCyberActor.TargetThreatLevel)
						{
							case THREAT_SUPERDANGER:
								MeleeFuzzy = 10;
								break;
							case THREAT_VERYDANGEROUS:
								MeleeFuzzy = 20;
								break;
							case THREAT_DANGEROUS:
								MeleeFuzzy = 25;
								break;
							case THREAT_ABOVENORMAL:
								MeleeFuzzy = 50;
								break;
							case THREAT_MILD:
								MeleeFuzzy = 75;
								break;
							default:
								MeleeFuzzy = 128;
								break;
						}
						break;
				}
			if ((MeleeFuzzy * CustomCyberActor.Health / CustomCyberActor.default.Health) > Random())
				PerformMelee = true;
			if (FitForFight)
			{
				if ((PerformMelee) && (CustomCyberActor.MeleeState) && CustomCyberActor.KAI_CheckMeleeRange(Target))
					CustomCyberActor.SetState(CustomCyberActor.MeleeState);
				else
					if ((CustomCyberActor.MissileState) && (CustomCyberActor.KAI_CheckMissileRange(Target, true)))
						CustomCyberActor.SetState(CustomCyberActor.MissileState);
			}
			return BH_SUCCESS;
		}
		else
			return BH_FAILURE;
	}
}
